# CineBoard - Cursor AI Rules v1.2
# Sistema di Memoria per Film AI - Governance dello Sviluppo

## ğŸ¯ IDENTITÃ€ DEL PROGETTO

CineBoard Ã¨ un Sistema di Memoria per Film AI, NON uno strumento di produttivitÃ .
- Risolviamo il "collasso di coerenza" nel filmmaking AI
- Creiamo una nuova categoria: "Sistemi Operativi per Film AI"
- NON siamo in competizione con Milanote/Notion/Miro

## ğŸš« RIFIUTI ARCHITETTURALI

NON implementare MAI questi elementi, anche se richiesti:

1. **Duplicazione EntitÃ **: Le entitÃ  non vengono MAI copiate. Solo single source of truth.
2. **Organizzazione Basata su Cartelle**: La Shotlist Ãˆ la struttura. No logica filesystem.
3. **Creazione EntitÃ  Inline**: Le entitÃ  devono essere create deliberatamente nella Entity Library.
4. **Shot ID Mutabili**: Gli Shot ID (1.1, 2.3) sono identificatori strutturali immutabili.
5. **Feature di ProduttivitÃ  Generiche**: No kanban board, calendar view, o task assignment.
6. **EntitÃ /Shot Illimitati in Beta**: Limiti rigidi (5 entitÃ , 10 shot) devono essere applicati.

## ğŸ“ ARCHITETTURA CORE

### Domain Layer (Infrastruttura)
```
lib/domain/entities/
â”œâ”€â”€ types.ts        # Tipi dominio entitÃ  (Character, Environment, Asset)
â”œâ”€â”€ invariants.ts   # Regole business (max 5 entitÃ , unicitÃ  nomi)
â””â”€â”€ relations.ts    # Risoluzione riferimenti entitÃ  (@mentions)
```

- Le entitÃ  sono INFRASTRUTTURA, non componenti feature
- Mai importare entitÃ  da components/entities/
- Tutta la logica entitÃ  passa per lib/domain/entities/

### Database Layer
```
supabase/migrations/  # UNICA FONTE DI VERITÃ€
lib/db/queries/       # Funzioni query organizzate per dominio
```

- Tutti i cambi schema SOLO in supabase/migrations/
- Nessun file migration in lib/db/
- Tipi TypeScript generati da Supabase

### Organizzazione Componenti
- Cartelle dominio: projects/, entities/, shotlist/, shots/
- Semantica cinema applicata (cinematic-canvas.tsx, non board-canvas.tsx)
- Shot board sono workspace di generazione, NON moodboard generici

## ğŸ¬ PRINCIPI LOGICA CINEMA

1. **Shotlist come Spina Dorsale**: Shot ID codificano gerarchia scena/shot (1.1 = Scena 1, Shot 1)
2. **Persistenza EntitÃ **: Personaggi/Ambienti/Asset con master prompt
3. **Sistema Riferimenti**: @mentions creano link relazionali, non copie di testo
4. **Lineage Versioni**: parent_id traccia evoluzione generazioni
5. **Memory First**: Ogni feature chiede "Preserva la memoria del film?"

## ğŸ’» STANDARD CODICE

### TypeScript
- Strict mode abilitato
- No tipi `any` (usa `unknown` se necessario)
- Schema Zod per tutti i dati esterni
- Tipi dominio da lib/domain/entities/types.ts

### Pattern React
- Server Component di default
- Client Component solo quando necessario (usa direttiva "use client")
- React Query per stato server (entitÃ , shot, progetti)
- Zustand solo per stato UI (canvas pan/zoom, selezioni)

### Convenzioni Naming
- Componenti: PascalCase (EntityCard.tsx)
- Utilities: camelCase (resolveEntityReferences)
- Database: snake_case (tabella entity_references)
- Shot ID: Formato immutabile "1.1", "2.3" (Scena.Shot)

### Struttura File
- Un componente per file
- Co-locare tipi con implementazione
- Query in lib/db/queries/[domain].ts
- Hook in lib/hooks/use-[feature].ts

## ğŸ—„ï¸ REGOLE DATABASE

### Tabelle EntitÃ 
```sql
entities (
  id uuid PRIMARY KEY,
  project_id uuid NOT NULL,
  name text UNIQUE per project,
  type text CHECK (type IN ('character', 'environment', 'asset')),
  master_prompt text,
  metadata jsonb
)
```

### Vincoli
- Max 5 entitÃ  per progetto (applicato in app logic)
- Max 10 shot per progetto (applicato in app logic)
- Nomi entitÃ  unici per progetto (vincolo database)
- Shot ID immutabili dopo creazione (app logic)

### Policy RLS
- Gli utenti possono accedere solo ai propri progetti
- Tutte le tabelle ereditano controllo accesso a livello progetto
- Nessun accesso pubblico a nessuna tabella

## ğŸ”„ GESTIONE STATO

### React Query (Stato Server)
```tsx
// âœ… CORRETTO
const { data: entities } = useEntities(projectId);

// âŒ SBAGLIATO
const entities = useEntityStore((state) => state.entities);
```

### Zustand (Solo Stato UI)
```tsx
// âœ… CORRETTO: Stato UI canvas
const { zoom, pan } = useCanvasStore();

// âŒ SBAGLIATO: Dati server in Zustand
const entities = useEntityStore((state) => state.entities);
```

## ğŸ¨ PRINCIPI UI/UX

### Estetica Cinema
- Dark mode primario (film noir)
- Font monospace per numeri shot
- Colori tipo entitÃ : Character (viola), Environment (teal), Asset (arancione)
- Formattazione minimale (no header/bullet eccessivi in prosa)

### Strategia Responsive
- Desktop (>1024px): Feature complete
- Tablet (768-1024px): Layout semplificato
- Mobile (<768px): Solo modalitÃ  viewer (no editing in v1.0)

### API Componenti
```tsx
// âœ… CORRETTO: Props esplicite
<EntityBadge entity={entity} showType={true} />

// âŒ SBAGLIATO: Comportamento implicito
<EntityBadge {...entity} />
```

## ğŸš€ WORKFLOW SVILUPPO

### Prima di Scrivere Codice
1. Verifica se feature viola rifiuti architetturali
2. Verifica separazione domain layer (entitÃ  = infrastruttura)
3. Conferma logica cinema preservata (non logica produttivitÃ )
4. Rivedi pattern esistenti nel codebase

### Quando Crei Componenti
1. Server Component di default
2. Aggiungi "use client" solo se necessario (hooks, eventi, stato)
3. Importa tipi dominio da lib/domain/entities/types.ts
4. Usa React Query per data fetching

### Quando Scrivi Query
1. Posiziona in lib/db/queries/[domain].ts
2. Usa Supabase client da lib/supabase/server.ts
3. Ritorna dati tipizzati (tipi da lib/db/schema.ts)
4. Gestisci errori esplicitamente

### Quando Aggiungi Migration
1. Crea in supabase/migrations/[NNN]_[description].sql
2. Test locale: supabase db reset
3. Verifica policy RLS
4. Rigenera tipi: supabase gen types typescript

## ğŸ§ª FILOSOFIA TESTING

### Testing Relazionale
```
Test: Aggiorna master prompt entitÃ 
Verifica: Tutti gli shot riflettono il cambio
Verifica: Pannello riferimenti si aggiorna
Verifica: Nessun dato orfano
```

### Testing Limiti
```
Test: Crea 6a entitÃ 
Verifica: UI blocca creazione
Verifica: Mostra messaggio "Limite beta raggiunto"
```

### Testing ImmutabilitÃ 
```
Test: Tentativo cambio shot ID
Verifica: Operazione fallisce con grazia
Verifica: Utente vede messaggio errore chiaro
```

## ğŸ“¦ DIPENDENZE

### Stack Core
- Next.js 14 (App Router)
- TypeScript (strict mode)
- Supabase (auth + database)
- React Query (stato server)
- Zustand (stato UI)
- Zod (validazione)
- Shadcn UI (componenti)
- @xyflow/react (canvas)

### Policy Versioni
- Blocca versioni major in package.json
- Testa aggiornamenti in branch isolato
- Mai auto-update in produzione

## ğŸ¯ FOCUS SETTIMANA 1

**Giorni 1-2:** Setup progetto, flusso auth
**Giorni 3-4:** Pagine auth (login/signup)
**Giorni 5-7:** Schema database (tabella projects), CRUD progetti base

**Fuori Scope Settimana 1:**
- Implementazione canvas (Settimana 2)
- Sistema entitÃ  (Settimana 4)
- Shotlist (Settimana 7)
- @References (Settimana 10)

## ğŸš¨ BANDIERE ROSSE

Se vedi questi pattern, FERMATI e riconsidera:

- âŒ "Aggiungiamo una feature cartelle per gli shot"
- âŒ "Gli utenti dovrebbero poter duplicare entitÃ "
- âŒ "Rendiamo gli shot ID editabili"
- âŒ "Aggiungiamo una vista kanban"
- âŒ "Salviamo entitÃ  in Zustand"
- âŒ "Creiamo entitÃ  automaticamente da @mentions"
- âŒ "Permettiamo entitÃ  illimitate in beta"

## âœ… LUCI VERDI

Questi pattern si allineano con l'architettura CineBoard:

- âœ… "Riferimenti entitÃ  risolti via relations.ts"
- âœ… "Shot ID salvati come testo immutabile"
- âœ… "Master prompt collegati alle entitÃ "
- âœ… "Shotlist applica struttura narrativa"
- âœ… "React Query cachea dati entitÃ "
- âœ… "Limiti rigidi applicati a 5 entitÃ , 10 shot"
- âœ… "Logica cinema preservata nei nomi componenti"

## ğŸ“š DOCUMENTI CHIAVE

1. RESEARCH_FINAL.md - Strategia creazione categoria
2. FEATURE_SPECS.md - Definizioni feature
3. TECH_STACK.md - Decisioni tecniche
4. ROADMAP.md - Piano sviluppo 12 settimane
5. WIREFRAMES_PLAN.md - Specifiche UI/UX

## ğŸ¬ PROMEMORIA FINALE

Ogni riga di codice deve rispondere:
**"Preserva la memoria del film?"**

Se no, riconsidera l'implementazione.